% chktex-file 44
% chktex-file 18
% chktex-file 36
% chktex-file 37
% chktex-file 11
% chktex-file 38
% chktex-file 25
% chktex-file 28
% chktex-file 35
% chktex-file 12
% chktex-file 16
% chktex-file 32
% chktex-file 26
% chktex-file 8



\chapter{System Coding}


  
\textbf{snc\_chat.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
import chromadb
from llama_index.indices import VectorStoreIndex
from llama_index.vector_stores import ChromaVectorStore
from llama_index.storage.storage_context import StorageContext
from llama_index import ServiceContext, set_global_service_context
from llama_index.llms import Cohere
from llama_index.embeddings import OpenAIEmbedding

from llama_index.llms import Ollama

from ...config import settings
import os

os.environ["OPENAI_API_KEY"] = settings.openai_api_key

db = chromadb.PersistentClient(path="./app/engine/chatsnc/chroma_db")

# get collection
chroma_collection = db.get_collection("college_laws")

# assign chroma as the vector_store to the context
vector_store = ChromaVectorStore(chroma_collection=chroma_collection)
storage_context = StorageContext.from_defaults(vector_store=vector_store)

# load your index from stored vectors
index = VectorStoreIndex.from_vector_store(
    vector_store,
    storage_context=storage_context,
)

def chat(query, chat_history):
    """
    Perform a chat using the given query and chat history.

    Args:
        query (str): The query to be used for the chat.
        chat_history (list): The chat history as a list.

    Returns:
        str: The response generated by the chat engine.
    """
    global index
    chat_engine = index.as_chat_engine(streaming=True)

    return chat_engine.stream_chat(query, chat_history=chat_history)  
\end{Verbatim}
\
\\
\textbf{load\_index.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
"""
This script loads documents into a vector store index using the ChromaDB library.

The script performs the following steps:
1. Imports necessary libraries and modules.
2. Sets the OpenAI API key as an environment variable.
3. Initializes an OpenAIEmbedding model for text embedding.
4. Sets the service context for the vector store index.
5. Loads documents from a specified directory using the SimpleDirectoryReader.
6. Initializes a ChromaDB client and creates a collection.
7. Assigns ChromaVectorStore as the vector store to the storage context.
8. Creates a vector store index from the loaded documents using the storage context.
"""

import chromadb
from llama_index import VectorStoreIndex, SimpleDirectoryReader, download_loader
from llama_index.vector_stores import ChromaVectorStore
from llama_index.storage.storage_context import StorageContext
from llama_index import ServiceContext, set_global_service_context
from llama_index.embeddings import OpenAIEmbedding
import os
import getpass

os.environ["OPENAI_API_KEY"] = getpass.getpass("OpenAI API Key:")

embed_model = OpenAIEmbedding(model="text-embedding-3-small")

service_context = ServiceContext.from_defaults(embed_model=embed_model)

set_global_service_context(service_context)

# load some documents
UnstructuredReader = download_loader("UnstructuredReader")
dir_reader = SimpleDirectoryReader(
    "./data",
    file_extractor={
        ".pdf": UnstructuredReader(),
        ".html": UnstructuredReader(),
        ".eml": UnstructuredReader(),
    },
)
documents = dir_reader.load_data()

# initialize client, setting path to save data
db = chromadb.PersistentClient(path="./chroma_db")

# create collection
chroma_collection = db.get_or_create_collection("college_laws")

# assign chroma as the vector_store to the context
vector_store = ChromaVectorStore(chroma_collection=chroma_collection)
storage_context = StorageContext.from_defaults(vector_store=vector_store)

# create your index
index = VectorStoreIndex.from_documents(documents, storage_context=storage_context)
\end{Verbatim}
\
\\
\textbf{utils.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash(password: str) -> str:
    return pwd_context.hash(password)


def verify(password: str, hashed: str) -> bool:
    return pwd_context.verify(password, hashed)

\end{Verbatim}
\
\\
\textbf{schemas.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional
from llama_index.llms import MessageRole
from typing import List


class UserCreate(BaseModel):
    email: EmailStr
    password: str


class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        from_attributes = True


class UserLogin(BaseModel):
    email: EmailStr
    password: str

    class Config:
        from_attributes = True


class Token(BaseModel):
    access_token: str
    token_type: str
    user: UserOut


class TokenData(BaseModel):
    id: Optional[int] = None


class ChatCreateOut(BaseModel):
    id: int

    class Config:
        from_attributes = True


class ChatOut(BaseModel):
    id: int
    history: Optional[List]
    created_at: datetime

    class Config:
        from_attributes = True


class History(BaseModel):
    role: MessageRole
    content: str


class HistoryOut(BaseModel):
    role: str
    content: str

\end{Verbatim}
\
\\
\textbf{oauth2.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from jose import JWTError, jwt
from datetime import datetime, timedelta
from . import schemas, database, models
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from .config import settings

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

SECRET_KEY = settings.secret_key
ALGORITHM = settings.algorithm
ACCESS_TOKEN_EXPIRE_MINUTES = settings.access_token_expire_minutes


def create_access_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def verify_access_token(token: str, credentials_exception):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        id: int = payload.get("user_id")  # type: ignore
        if id is None:
            raise credentials_exception
        token_data = schemas.TokenData(id=id)
        return token_data
    except JWTError:
        raise credentials_exception


def get_current_user(
    token: str = Depends(oauth2_scheme), db: Session = Depends(database.get_db)
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    token_data = verify_access_token(token, credentials_exception)
    user = db.query(models.User).filter(models.User.id == token_data.id).first()
    if not user:
        raise credentials_exception
    return user

\end{Verbatim}

\
\\
\textbf{models.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from .database import Base
from sqlalchemy import Column, Integer, String, TIMESTAMP, text, ForeignKey
from sqlalchemy.orm import relationship


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, nullable=False)
    email = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=False)
    created_at = Column(
        TIMESTAMP(timezone=True), nullable=False, server_default=text("now()")
    )


class Chat(Base):
    __tablename__ = "chats"

    id = Column(Integer, primary_key=True, nullable=False)
    user_id = Column(
        Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )
    history = Column(String)

    created_at = Column(
        TIMESTAMP(timezone=True), nullable=False, server_default=text("now()")
    )

    owner = relationship("User")

\end{Verbatim}
\
\\
\textbf{main.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from .config import settings

if settings.app == "prod":
    __import__("pysqlite3")
    import sys

    sys.modules["sqlite3"] = sys.modules.pop("pysqlite3")
from fastapi import FastAPI
from .routers import user, auth, chatsnc
from fastapi.middleware.cors import CORSMiddleware
from . import models
from .database import engine


# models.Base.metadata.create_all(bind=engine)

app = FastAPI()

origins = [
    "http://chatsnc.vercel.app",
    "https://chatsnc.vercel.app",
    "http://localhost:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(user.router)
app.include_router(auth.router)
app.include_router(chatsnc.router)
\end{Verbatim}

\
\\
\textbf{database.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

SQLALCHEMY_DATABASE_URL = f"postgresql://{settings.database_username}:{settings.database_password}@{settings.database_hostname}:{settings.database_port}/{settings.database_name}"

engine = create_engine(SQLALCHEMY_DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
  
\end{Verbatim}

\
\\
\textbf{config.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_hostname: str
    database_port: str
    database_password: str
    database_username: str
    database_name: str
    secret_key: str
    algorithm: str
    access_token_expire_minutes: int
    openai_api_key: str
    app: str

    class Config:
        env_file = ".env"

settings = Settings()  # type: ignore
\end{Verbatim}

\
\\
\textbf{auth.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from ..database import get_db
from .. import models, schemas, utils, oauth2
from sqlalchemy.orm import Session
from fastapi import status, HTTPException, Depends, APIRouter
from fastapi.security.oauth2 import OAuth2PasswordRequestForm

router = APIRouter(
    tags=["Authentication"],
)


@router.post("/login", status_code=status.HTTP_200_OK, response_model=schemas.Token)
def login(
    user_credentials: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db),
):
    user = (
        db.query(models.User)
        .filter(models.User.email == user_credentials.username)
        .first()
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Invalid credentials"
        )
    if not utils.verify(user_credentials.password, user.password):  # type: ignore
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Invalid credentials"
        )

    access_token = oauth2.create_access_token(data={"user_id": user.id})
    return {"access_token": access_token, "token_type": "bearer", "user": user}

\end{Verbatim}
\
\\
\textbf{chatsnc.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from .. import models, schemas
from ..database import get_db
from sqlalchemy import func
from sqlalchemy.orm import Session
from typing import List
from fastapi import status, HTTPException, Depends, Response, APIRouter
from .. import oauth2
from typing import List, Optional
from ..engine.chatsnc import snc_chat
from pydantic import BaseModel
import asyncio
from fastapi.responses import StreamingResponse
from llama_index.llms import ChatMessage, MessageRole
import json
from fastapi.encoders import jsonable_encoder

router = APIRouter(
    prefix="/chat",
    tags=["ChatSNC"],
)


async def astreamer(generator):
    try:
        for i in generator:
            yield (i)
            await asyncio.sleep(0.1)
    except asyncio.CancelledError as e:
        print("cancelled")


@router.post("/generate", status_code=status.HTTP_201_CREATED)
def generate_chat(
    query: str,
    history: List[schemas.History],
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chat_history = [
        ChatMessage(
            role=MessageRole.USER,
            content="Hello assistant, we are having a insightful discussion about Rules of SN College today.",
        ),
        ChatMessage(role=MessageRole.ASSISTANT, content="Okay, sounds good."),
    ]
    for h in history:
        chat_history.append(ChatMessage(role=h.role, content=h.content))
    response = snc_chat.chat(query, chat_history)
    return StreamingResponse(astreamer(response.response_gen), media_type="text/plain")


@router.post(
    "/", status_code=status.HTTP_201_CREATED, response_model=schemas.ChatCreateOut
)
def create_chat(
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    new_chat = models.Chat(
        user_id=user.id,
    )
    db.add(new_chat)
    db.commit()
    db.refresh(new_chat)
    return new_chat


@router.put("/{id}", status_code=status.HTTP_200_OK)
def update_chat(
    id: int,
    history: List[schemas.HistoryOut],
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chat_str = json.dumps(jsonable_encoder(history))

    chat_query = db.query(models.Chat).filter(models.Chat.id == id)
    chat = chat_query.first()
    if not chat:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Chat not found"
        )
    if chat.user_id != user.id:  # type: ignore
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    chat_query.update({"history": chat_str}, synchronize_session=False)
    db.commit()

    return {"message": "Chat updated successfully"}


@router.get("/{id}", status_code=status.HTTP_200_OK)
def get_chat(
    id: int,
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chat_query = db.query(models.Chat).filter(models.Chat.id == id)
    chat = chat_query.first()
    if not chat:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Chat not found"
        )
    if chat.user_id != user.id:  # type: ignore
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    chat_str = chat.history
    chat_history = json.loads(chat_str)  # type: ignore
    return chat_history


@router.get("/", status_code=status.HTTP_200_OK, response_model=List[schemas.ChatOut])
def get_chats(
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chats = (
        db.query(models.Chat)
        .filter(models.Chat.user_id == user.id)
        .order_by(models.Chat.created_at.desc())
        .all()
    )

    for chat in chats:
        if chat.history:  # type: ignore
            chat.history = json.loads(chat.history)  # type: ignore
    return chats

\end{Verbatim}

\
\\
\textbf{user.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from .. import models, schemas, utils
from ..database import get_db
from sqlalchemy.orm import Session
from fastapi import status, HTTPException, Depends, APIRouter

router = APIRouter(
    prefix="/users",
    tags=["Users"],
)


@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.UserOut)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    # Check if user already exists
    db_user = db.query(models.User).filter(models.User.email == user.email).first()
    if db_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered",
        )

    user.password = utils.hash(user.password)

    new_user = models.User(**user.model_dump())
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user


@router.get("/{id}", response_model=schemas.UserOut)
def get_user(id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return user

\end{Verbatim}

\
\\
\textbf{main.ts}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'

import App from './App.vue'
import router from './router'
import './axios'

const app = createApp(App)

app.use(createPinia())
app.use(router)

app.mount('#app')

\end{Verbatim}

\
\\
\textbf{utils.ts}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
import { jwtDecode } from 'jwt-decode'

export function isTokenExpired(token: string) {
  const { exp } = jwtDecode<{ exp: number }>(token)
  return Date.now() >= exp * 1000
}  
\end{Verbatim}

\
\\
\textbf{axios.ts}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
import axios from 'axios'

axios.defaults.baseURL = import.meta.env.VITE_API_ENDPOINT
\end{Verbatim}

\
\\
\textbf{router/index.ts}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
import { createRouter, createWebHistory } from 'vue-router'
import ChatSNCVue from '../views/ChatSNC.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'chatsnc',
      component: ChatSNCVue,
    },
    {
      path: '/login',
      name: 'login',
      // route level code-splitting
      // this generates a separate chunk (About.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import('../views/Login.vue'),
    },
    {
      path: '/register',
      name: 'register',
      // route level code-splitting
      // this generates a separate chunk (About.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import('../views/Register.vue'),
    },
  ],
})

export default router
\end{Verbatim}
\
\\
\textbf{app.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<script setup lang="ts">
import { RouterLink, RouterView } from 'vue-router'
import Nav from './components/Nav.vue'
</script>

<template>
  <div class="relative h-full flex w-full text-gray-light overflow-hidden font-roboto">
    <div class="flex-1 h-full max-w-full flex flex-col relative">
      <Nav />
      <div class="relative h-full w-full flex-1 overflow-auto transition-width">
        <RouterView />
      </div>
    </div>
  </div>
</template>

\end{Verbatim}
\
\\
\textbf{Login.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="text-gray-light h-full flex-1 flex flex-col">
    <div class="flex-1 overflow-hidden">
      <div class="relative h-full">
        <div class="flex h-full flex-col items-center justify-center">
          <form class="flex flex-col gap-3 bg-gray-medium items-center px-10 py-8 rounded-md" @submit.prevent="loginUser">
            <p class="text-center text-2xl font-medium mb-3">Login to ChatSNC</p>
            <div class="flex flex-col gap-1">
              <label for="email" class="text-base">Email</label>
              <input type="email" id="username" name="username" class="bg-transparent border h-8 rounded-md w-60 pl-2 focus:outline-none focus:ring-1 ring-slate-300" v-model="data.username" />
            </div>
            <div class="flex flex-col gap-1">
              <label for="password" class="text-base">Password</label>
              <input type="password" id="password" name="password" class="bg-transparent border h-8 rounded-md w-60 pl-2 focus:outline-none focus:ring-1 ring-slate-300" v-model="data.password" />
            </div>
            <button class="text-gray-medium flex justify-center text-base bg-gray-light w-fit px-4 py-1 font-medium rounded-md">
              <p v-if="!loading">Login</p>
              <div v-else>
                <svg class="w-6 h-6 mx-2 text-gray-medium animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-10" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              </div>
            </button>
            <p v-if="error" class="text-red-500 text-sm">{{ error }}</p>
            <p class="text-sm">Don't have an account? <router-link class="text-blue-primary" to="/register">Register</router-link></p>
          </form>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts" setup>
import axios from 'axios'
import { ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

const data = ref({
  username: '',
  password: '',
})

const loading = ref(false)

const error = ref('')

async function loginUser() {
  try {
    loading.value = true
    const response = await axios.post(
      'login',
      {
        username: data.value.username,
        password: data.value.password,
      },
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      }
    )
    error.value = ''
    console.log(response.data)
    localStorage.setItem('token', response.data.access_token)
    router.push('/')
  } catch (e: any) {
    if (e.response.status === 403) {
      error.value = e.response.data.detail
    }
    if (e.response.status === 422) {
      error.value = 'Enter a valid email and password'
    }
  } finally {
    loading.value = false
  }
}
</script>

\end{Verbatim}
\
\\
\textbf{Register.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="text-gray-light h-full flex-1 flex flex-col">
    <div class="flex-1 overflow-hidden">
      <div class="relative h-full">
        <div class="flex h-full flex-col items-center justify-center">
          <form class="flex flex-col gap-3 bg-gray-medium items-center px-10 py-8 rounded-md" @submit.prevent="registerUser">
            <p class="text-center text-2xl font-medium mb-3">Register to ChatSNC</p>
            <div class="flex flex-col gap-1">
              <label for="email" class="text-base">Email</label>
              <input type="email" id="email" name="email" class="bg-transparent border h-8 rounded-md w-60 pl-2 focus:outline-none focus:ring-1 ring-slate-300" v-model="data.email" />
            </div>
            <div class="flex flex-col gap-1">
              <label for="password" class="text-base">Password</label>
              <input type="password" id="password" name="password" class="bg-transparent border h-8 rounded-md w-60 pl-2 focus:outline-none focus:ring-1 ring-slate-300" v-model="data.password" />
            </div>
            <button class="text-gray-medium text-base bg-gray-light w-fit px-4 py-1 font-medium rounded-md">
              <p v-if="!loading">Register</p>
              <div v-else>
                <svg class="w-6 h-6 mx-2 text-gray-medium animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-10" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              </div>
            </button>
            <p v-if="error" class="text-red-500 text-sm">{{ error }}</p>
            <p class="text-sm">Don't have an account? <router-link class="text-blue-primary" to="/login">Login</router-link></p>
          </form>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts" setup>
import axios from 'axios'
import { ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

const data = ref({
  email: '',
  password: '',
})

const loading = ref(false)

const error = ref('')

async function registerUser() {
  try {
    loading.value = true
    const response = await axios.post('users/', {
      email: data.value.email,
      password: data.value.password,
    })

    error.value = ''
    // redirect to login page
    router.push('/login')
  } catch (e: any) {
    if (e.response.status === 403 || e.response.status === 400) {
      error.value = e.response.data.detail
    }
    if (e.response.status === 422) {
      error.value = 'Enter a valid email and password'
    }
  } finally {
    loading.value = false
  }
}
</script>

\end{Verbatim}

\
\\
\textbf{ChatSNC.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="flex h-full md:px-12 gap-8">
    <div class="text-gray-light h-full flex-1 flex flex-col">
      <div class="flex-1 overflow-hidden">
        <div class="relative h-full" v-if="chat.length === 0">
          <StartScreen :sampleQueries="sampleQueries" @submitSampleQuery="submitSampleQuery" />
        </div>
        <div class="relative h-full md:mt-4" v-else>
          <ChatDisplay :chat="chat" />
        </div>
      </div>

      <div class="w-full pt-2 md:pt-0">
        <form class="stretch mx-2 flex flex-row gap-3 last:mb-2 md:last:mb-6 lg:max-w-2xl xl:max-w-3xl" @submit.prevent="loading ? null : sendMessage()">
          <div class="relative flex h-full flex-1 items-stretch md:flex-col">
            <div class="flex w-full items-center">
              <div
                class="overflow-hidden flex w-full flex-grow relative border rounded-full border-gray items-center gap-2 [&:has(input:focus)]:border-gray-light [&:has(input:focus)]:shadow-[0_2px_6px_rgba(0,0,0,.05)]"
              >
                <span class="cursor-pointer" @click="chat = []">
                  <IconNew />
                </span>
                <input
                  placeholder="Type your message here..."
                  class="w-full h-7 resize-none border-0 bg-transparent focus:ring-offset-0 focus:outline-none placeholder:font-normal placeholder-gray-light focus:ring-0 focus-visible:ring-0"
                  style="overflow-y: hidden"
                  v-model="message"
                />

                <span class="cursor-pointer" @click="loading ? null : sendMessage()">
                  <IconSent />
                </span>
              </div>
            </div>
          </div>
        </form>
      </div>
    </div>
    <History @getChat="getChat" :key="historyKey" />
  </div>
</template>

<script lang="ts" setup>
import { useRouter } from 'vue-router'
import { onMounted } from 'vue'
import { isTokenExpired } from '../utils'
import { ref } from 'vue'
import type { Ref } from 'vue'
import StartScreen from './../components/OpeningScreen.vue'
import ChatDisplay from './../components/ChatDisplay.vue'
import History from './../components/History.vue'
import IconNew from './../components/Icon/New.vue'
import IconSent from './../components/Icon/Sent.vue'
import axios from 'axios'

const base_url = import.meta.env.VITE_API_ENDPOINT

const router = useRouter()

const chat_id: Ref<Number> = ref(0)

type Chat = {
  content: string
  role: string
}

const sampleQueries = ['What is the minimum attendance required in SN College?', 'Who was the first HOD of physics department?', 'What are the rules regarding mobile phones in SN College?']

const loading = ref(false)

const chat: Ref<Chat[]> = ref([])
const message = ref('')

const historyKey = ref(0)

const forceHistoryRerender = () => {
  historyKey.value += 1
}

function submitSampleQuery(query: string) {
  message.value = query
  sendMessage()
}

async function createChat() {
  try {
    const response = await fetch(`${base_url}chat/`, {
      method: 'POST',
      headers: {
        Authorization: 'Bearer ' + localStorage.getItem('token'),
      },
    })
    const data = await response.json()
    return data.id
  } catch (e: any) {}
}

async function updateChat(chat_history: any) {
  try {
    const response = await fetch(`${base_url}chat/${chat_id.value}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Authorization: 'Bearer ' + localStorage.getItem('token'),
      },
      body: JSON.stringify(chat_history),
    })
  } catch (e: any) {}
}

async function sendMessage() {
  try {
    loading.value = true

    const message_copy = message.value
    message.value = ''
    const chat_to_send = chat.value.slice()
    chat.value.push({
      role: 'user',
      content: message_copy,
    })
    if (chat.value.length === 1) {
      chat_id.value = await createChat()
    }
    const response = await fetch(
      `${base_url}chat/generate?` +
        new URLSearchParams({
          query: message_copy,
        }),
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer ' + localStorage.getItem('token'),
        },
        body: JSON.stringify(chat_to_send),
      }
    )

    // stream
    const reader = response.body?.getReader()

    const stream = new ReadableStream({
      start(controller) {
        chat.value.push({
          content: '',
          role: 'assistant',
        })
        // The following function handles each data chunk
        function push() {
          // "done" is a Boolean and value a "Uint8Array"
          reader?.read().then(({ done, value }) => {
            // Is there no more data to read?
            if (done) {
              // Tell the browser that we have finished sending data
              controller.close()

              // Update the chat after the assistant has finished sending data
              loading.value = false

              updateChat(chat.value)
              forceHistoryRerender()
              return
            }
            // Get the data and send it to the browser via the controller
            const text = new TextDecoder().decode(value)
            chat.value[chat.value.length - 1].content += text
            controller.enqueue(value)

            // Continue pushing data
            push()
          })
        }
        console.log(chat.value)
        push()
      },
    })
  } catch (e: any) {
    console.log(e)
  } finally {
  }
}

async function getChat(id: number) {
  try {
    console.log(id)
    const response = await axios.get(`chat/${id}`, {
      headers: {
        Authorization: 'Bearer ' + localStorage.getItem('token'),
      },
    })
    console.log(response.data)
    chat.value = response.data
    chat_id.value = id
  } catch (e: any) {}
}

onMounted(() => {
  const token = localStorage.getItem('token')
  if (!token || isTokenExpired(token)) {
    router.push('/login')
  }
})
</script>
\end{Verbatim}

\
\\
\textbf{ChatDisplay.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="h-full w-full overflow-y-auto">
    <div class="flex flex-col gap-6 px-4 py-4 md:px-0">
      <div v-for="message in chat" :key="message.content" class="flex flex-col">
        <div class="flex flex-col">
          <p class="font-semibold">{{ message.role === 'user' ? 'You' : 'ChatSNC' }}</p>
          <p class="whitespace-pre-wrap">{{ message.content }}</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts" setup>
type Chat = {
  content: string
  role: string
}

defineProps({
  chat: {
    type: Array<Chat>,
    required: true,
  },
})
</script>

\end{Verbatim}
\
\\
\textbf{History.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="w-full md:w-4/12 hidden md:flex self-start text-gray-light border border-gray mt-8 rounded-md shadow-lg py-4 px-4">
    <div class="flex w-full flex-col gap-2">
      <h1 class="text-lg font-bold ml-2">Recent Chats</h1>
      <div v-if="loading" class="flex w-full justify-center items-center">
        <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-gray-light"></div>
      </div>
      <div class="flex w-full gap-2 flex-col">
        <div
          v-for="(item, index) in history.slice(0, 10)"
          class="flex w-full cursor-pointer py-2 px-3 hover:bg-gray-medium transition flex-col gap-2 border-b rounded-md bg-gray-medium border-gray hover:border-l-4 hover:border-orange-300"
          :key="index"
          @click="$emit('getChat', item.id)"
        >
          <div class="flex flex-row w-full">
            <div class="text-sm w-full overflow-ellipsis overflow-hidden whitespace-nowrap">{{ displayString(item.chats) }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { ref, onMounted, onRenderTriggered } from 'vue'
import type { Ref } from 'vue'
import axios from 'axios'

const loading = ref(false)

type Chat = {
  content: string
  role: string
}

type History = {
  id: number
  chats: Chat[]
}

const history: Ref<History[]> = ref([])

function displayString(item: any) {
  return item[0].content
}

async function getChats() {
  try {
    loading.value = true
    const response = await axios.get('chat/', {
      headers: {
        Authorization: 'Bearer ' + localStorage.getItem('token'),
      },
    })
    console.log(response.data)
    for (const item of response.data) {
      if (item.history) {
        history.value.push({
          id: item.id,
          chats: item.history,
        })
      }
    }
    console.log(history.value)
  } catch (e: any) {
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  getChats()
})

onRenderTriggered(() => {
  getChats()
})
</script>

\end{Verbatim}

\
\\
\textbf{Nav.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="w-full px-4 md:px-12 flex sticky top-0 z-10 min-h-[40px] shadow-md shadow-shadow py-3 justify-between items-center">
    <p class="text-xl font-bold">ChatSNC</p>
    <div v-if="isUserInHomePage()" class="cursor-pointer" @click="logoutUser">
      <svg width="36" height="36" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="25" cy="25" r="24" stroke="#dedede" stroke-width="2" />
        <path
          d="M15 37V12H27.5V14.7778H17.7778V34.2222H27.5V37H15ZM33.0556 31.4444L31.1458 29.4306L34.6875 25.8889H23.3333V23.1111H34.6875L31.1458 19.5694L33.0556 17.5556L40 24.5L33.0556 31.4444Z"
          fill="#dedede"
        />
      </svg>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { useRouter } from 'vue-router'
import axios from 'axios'

const router = useRouter()

// check if user is in home page
function isUserInHomePage() {
  return router.currentRoute.value.path === '/'
}

function logoutUser() {
  localStorage.removeItem('token')
  axios.defaults.headers.common['Authorization'] = ''
  router.push('/login')
}
</script>

\end{Verbatim}
\
\\
\textbf{OpeningScreen.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="flex h-full flex-col items-center justify-center">
    <div class="flex flex-col px-4 md:px-0 items-center gap-6">
      <p class="text-2xl md:text-2xl mb-4 text-center text-gray-light font-medium">
        Ask about the website content of <a href="https://snckollam.ac.in/" target="_blank" class="transition text-blue-200 hover:underline hover:text-gray-light">SN College</a>
      </p>
      <div class="flex flex-col md:flex-row gap-2">
        <button
          v-for="query in sampleQueries"
          :key="String(query)"
          class="text-orange-100 text-base pl-6 pr-6 hover:shadow-md transition hover:shadow-gray py-5 border text-left border-orange-100 rounded-3xl flex align-top font-normal"
          @click="$emit('submitSampleQuery', query)"
        >
          >> {{ query }}
        </button>
      </div>
      <p class="text-sm text-gray-light">- Please do not enter any private or sensitive information.</p>
    </div>
  </div>
</template>

<script lang="ts" setup>
defineProps({
  sampleQueries: {
    type: Array,
    required: true,
  },
})
</script>

\end{Verbatim}

\
\\
\textbf{index.html}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="./favicon.ico" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;500;600;700;800&display=swap" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChatSNC</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>

\end{Verbatim}

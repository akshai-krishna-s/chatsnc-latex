% chktex-file 44
% chktex-file 18
% chktex-file 36
% chktex-file 37
% chktex-file 11
% chktex-file 38
% chktex-file 25
% chktex-file 28
% chktex-file 35
% chktex-file 12
% chktex-file 16
% chktex-file 32
% chktex-file 26
% chktex-file 8


\chapter{System Coding and Unit Testing}

\section{System Coding}

\subsection{Program List}


\begin{table}[h!]
  \centering
  
  \begin{tabular}{|p{4cm}|p{8cm}|}
    \hline
    \multicolumn{1}{|c|}{\textbf{Program Name}} & \multicolumn{1}{c|}{\textbf{Description}}\\ \hline
    snc\_chat.py & Chat engine for the ChatSNC application\\ \hline
    load\_index.py & Load documents as vector into the vector database\\ \hline
    main.py & Main FastAPI application\\ \hline
    auth.py & Authentication routes\\ \hline
    chatsnc.py & ChatSNC routes\\ \hline
    user.py & User routes\\ \hline
  \end{tabular}
  \vspace*{8pt}

  \caption{Program List}
\end{table}

\subsection{Program Code}
  
\textbf{snc\_chat.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
import chromadb
from llama_index.indices import VectorStoreIndex
from llama_index.vector_stores import ChromaVectorStore
from llama_index.storage.storage_context import StorageContext
from llama_index import ServiceContext, set_global_service_context
from llama_index.llms import Cohere
from llama_index.embeddings import OpenAIEmbedding

from llama_index.llms import Ollama

from ...config import settings
import os

os.environ["OPENAI_API_KEY"] = settings.openai_api_key

db = chromadb.PersistentClient(path="./app/engine/chatsnc/chroma_db")

# get collection
chroma_collection = db.get_collection("college_laws")

# assign chroma as the vector_store to the context
vector_store = ChromaVectorStore(chroma_collection=chroma_collection)
storage_context = StorageContext.from_defaults(vector_store=vector_store)

# load your index from stored vectors
index = VectorStoreIndex.from_vector_store(
    vector_store,
    storage_context=storage_context,
)

def chat(query, chat_history):
    """
    Perform a chat using the given query and chat history.

    Args:
        query (str): The query to be used for the chat.
        chat_history (list): The chat history as a list.

    Returns:
        str: The response generated by the chat engine.
    """
    global index
    chat_engine = index.as_chat_engine(streaming=True)

    return chat_engine.stream_chat(query, chat_history=chat_history)  
\end{Verbatim}
\
\\
\textbf{load\_index.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
"""
This script loads documents into a vector store index using the ChromaDB library.

The script performs the following steps:
1. Imports necessary libraries and modules.
2. Sets the OpenAI API key as an environment variable.
3. Initializes an OpenAIEmbedding model for text embedding.
4. Sets the service context for the vector store index.
5. Loads documents from a specified directory using the SimpleDirectoryReader.
6. Initializes a ChromaDB client and creates a collection.
7. Assigns ChromaVectorStore as the vector store to the storage context.
8. Creates a vector store index from the loaded documents using the storage context.
"""

import chromadb
from llama_index import VectorStoreIndex, SimpleDirectoryReader, download_loader
from llama_index.vector_stores import ChromaVectorStore
from llama_index.storage.storage_context import StorageContext
from llama_index import ServiceContext, set_global_service_context
from llama_index.embeddings import OpenAIEmbedding
import os
import getpass

os.environ["OPENAI_API_KEY"] = getpass.getpass("OpenAI API Key:")

embed_model = OpenAIEmbedding(model="text-embedding-3-small")

service_context = ServiceContext.from_defaults(embed_model=embed_model)

set_global_service_context(service_context)

# load some documents
UnstructuredReader = download_loader("UnstructuredReader")
dir_reader = SimpleDirectoryReader(
    "./data",
    file_extractor={
        ".pdf": UnstructuredReader(),
        ".html": UnstructuredReader(),
        ".eml": UnstructuredReader(),
    },
)
documents = dir_reader.load_data()

# initialize client, setting path to save data
db = chromadb.PersistentClient(path="./chroma_db")

# create collection
chroma_collection = db.get_or_create_collection("college_laws")

# assign chroma as the vector_store to the context
vector_store = ChromaVectorStore(chroma_collection=chroma_collection)
storage_context = StorageContext.from_defaults(vector_store=vector_store)

# create your index
index = VectorStoreIndex.from_documents(documents, storage_context=storage_context)
\end{Verbatim}

\
\\
\textbf{main.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from .config import settings

if settings.app == "prod":
    __import__("pysqlite3")
    import sys

    sys.modules["sqlite3"] = sys.modules.pop("pysqlite3")
from fastapi import FastAPI
from .routers import user, auth, chatsnc
from fastapi.middleware.cors import CORSMiddleware
from . import models
from .database import engine


# models.Base.metadata.create_all(bind=engine)

app = FastAPI()

origins = [
    "http://chatsnc.vercel.app",
    "https://chatsnc.vercel.app",
    "http://localhost:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(user.router)
app.include_router(auth.router)
app.include_router(chatsnc.router)
\end{Verbatim}

\
\\
\textbf{auth.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from ..database import get_db
from .. import models, schemas, utils, oauth2
from sqlalchemy.orm import Session
from fastapi import status, HTTPException, Depends, APIRouter
from fastapi.security.oauth2 import OAuth2PasswordRequestForm

router = APIRouter(
    tags=["Authentication"],
)

 
@router.post("/login", status_code=status.HTTP_200_OK, response_model=schemas.Token)
def login(
    user_credentials: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db),
):
    user = (
        db.query(models.User)
        .filter(models.User.email == user_credentials.username)
        .first()
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Invalid credentials"
        )
    if not utils.verify(user_credentials.password, user.password):  # type: ignore
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Invalid credentials"
        )

    access_token = oauth2.create_access_token(data={"user_id": user.id})
    return {"access_token": access_token, "token_type": "bearer", "user": user}

\end{Verbatim}
\
\\
\textbf{chatsnc.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from .. import models, schemas
from ..database import get_db
from sqlalchemy import func
from sqlalchemy.orm import Session
from typing import List
from fastapi import status, HTTPException, Depends, Response, APIRouter
from .. import oauth2
from typing import List, Optional
from ..engine.chatsnc import snc_chat
from pydantic import BaseModel
import asyncio
from fastapi.responses import StreamingResponse
from llama_index.llms import ChatMessage, MessageRole
import json
from fastapi.encoders import jsonable_encoder

router = APIRouter(
    prefix="/chat",
    tags=["ChatSNC"],
)


async def astreamer(generator):
    try:
        for i in generator:
            yield (i)
            await asyncio.sleep(0.1)
    except asyncio.CancelledError as e:
        print("cancelled")


@router.post("/generate", status_code=status.HTTP_201_CREATED)
def generate_chat(
    query: str,
    history: List[schemas.History],
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chat_history = [
        ChatMessage(
            role=MessageRole.USER,
            content="Hello assistant, we are having a insightful discussion about Rules of SN College today.",
        ),
        ChatMessage(role=MessageRole.ASSISTANT, content="Okay, sounds good."),
    ]
    for h in history:
        chat_history.append(ChatMessage(role=h.role, content=h.content))
    response = snc_chat.chat(query, chat_history)
    return StreamingResponse(astreamer(response.response_gen), media_type="text/plain")


@router.post(
    "/", status_code=status.HTTP_201_CREATED, response_model=schemas.ChatCreateOut
)
def create_chat(
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    new_chat = models.Chat(
        user_id=user.id,
    )
    db.add(new_chat)
    db.commit()
    db.refresh(new_chat)
    return new_chat


@router.put("/{id}", status_code=status.HTTP_200_OK)
def update_chat(
    id: int,
    history: List[schemas.HistoryOut],
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chat_str = json.dumps(jsonable_encoder(history))

    chat_query = db.query(models.Chat).filter(models.Chat.id == id)
    chat = chat_query.first()
    if not chat:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Chat not found"
        )
    if chat.user_id != user.id:  # type: ignore
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    chat_query.update({"history": chat_str}, synchronize_session=False)
    db.commit()

    return {"message": "Chat updated successfully"}


@router.get("/{id}", status_code=status.HTTP_200_OK)
def get_chat(
    id: int,
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chat_query = db.query(models.Chat).filter(models.Chat.id == id)
    chat = chat_query.first()
    if not chat:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Chat not found"
        )
    if chat.user_id != user.id:  # type: ignore
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    chat_str = chat.history
    chat_history = json.loads(chat_str)  # type: ignore
    return chat_history


@router.get("/", status_code=status.HTTP_200_OK, response_model=List[schemas.ChatOut])
def get_chats(
    db: Session = Depends(get_db),
    user: schemas.UserOut = Depends(oauth2.get_current_user),
):
    chats = (
        db.query(models.Chat)
        .filter(models.Chat.user_id == user.id)
        .order_by(models.Chat.created_at.desc())
        .all()
    )

    for chat in chats:
        if chat.history:  # type: ignore
            chat.history = json.loads(chat.history)  # type: ignore
    return chats

\end{Verbatim}

\
\\
\textbf{user.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from .. import models, schemas, utils
from ..database import get_db
from sqlalchemy.orm import Session
from fastapi import status, HTTPException, Depends, APIRouter

router = APIRouter(
    prefix="/users",
    tags=["Users"],
)


@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.UserOut)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    # Check if user already exists
    db_user = db.query(models.User).filter(models.User.email == user.email).first()
    if db_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered",
        )

    user.password = utils.hash(user.password)

    new_user = models.User(**user.model_dump())
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user


@router.get("/{id}", response_model=schemas.UserOut)
def get_user(id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return user

\end{Verbatim}
\
\\
\textbf{ChatSNC.vue}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
<template>
  <div class="flex h-full md:px-12 gap-8">
    <div class="text-gray-light h-full flex-1 flex flex-col">
      <div class="flex-1 overflow-hidden">
        <div class="relative h-full" v-if="chat.length === 0">
          <StartScreen :sampleQueries="sampleQueries" @submitSampleQuery="submitSampleQuery" />
        </div>
        <div class="relative h-full md:mt-4" v-else>
          <ChatDisplay :chat="chat" />
        </div>
      </div>

      <div class="w-full pt-2 md:pt-0">
        <form class="stretch mx-2 flex flex-row gap-3 last:mb-2 md:last:mb-6 lg:max-w-2xl xl:max-w-3xl" @submit.prevent="loading ? null : sendMessage()">
          <div class="relative flex h-full flex-1 items-stretch md:flex-col">
            <div class="flex w-full items-center">
              <div
                class="overflow-hidden flex w-full flex-grow relative border rounded-full border-gray items-center gap-2 [&:has(input:focus)]:border-gray-light [&:has(input:focus)]:shadow-[0_2px_6px_rgba(0,0,0,.05)]"
              >
                <span class="cursor-pointer" @click="chat = []">
                  <IconNew />
                </span>
                <input
                  placeholder="Type your message here..."
                  class="w-full h-7 resize-none border-0 bg-transparent focus:ring-offset-0 focus:outline-none placeholder:font-normal placeholder-gray-light focus:ring-0 focus-visible:ring-0"
                  style="overflow-y: hidden"
                  v-model="message"
                />

                <span class="cursor-pointer" @click="loading ? null : sendMessage()">
                  <IconSent />
                </span>
              </div>
            </div>
          </div>
        </form>
      </div>
    </div>
    <History @getChat="getChat" :key="historyKey" />
  </div>
</template>

<script lang="ts" setup>
import { useRouter } from 'vue-router'
import { onMounted } from 'vue'
import { isTokenExpired } from '../utils'
import { ref } from 'vue'
import type { Ref } from 'vue'
import StartScreen from './../components/OpeningScreen.vue'
import ChatDisplay from './../components/ChatDisplay.vue'
import History from './../components/History.vue'
import IconNew from './../components/Icon/New.vue'
import IconSent from './../components/Icon/Sent.vue'
import axios from 'axios'

const base_url = import.meta.env.VITE_API_ENDPOINT

const router = useRouter()

const chat_id: Ref<Number> = ref(0)

type Chat = {
  content: string
  role: string
}

const sampleQueries = ['What is the minimum attendance required in SN College?', 'Who was the first HOD of physics department?', 'What are the rules regarding mobile phones in SN College?']

const loading = ref(false)

const chat: Ref<Chat[]> = ref([])
const message = ref('')

const historyKey = ref(0)

const forceHistoryRerender = () => {
  historyKey.value += 1
}

function submitSampleQuery(query: string) {
  message.value = query
  sendMessage()
}

async function createChat() {
  try {
    const response = await fetch(`${base_url}chat/`, {
      method: 'POST',
      headers: {
        Authorization: 'Bearer ' + localStorage.getItem('token'),
      },
    })
    const data = await response.json()
    return data.id
  } catch (e: any) {}
}

async function updateChat(chat_history: any) {
  try {
    const response = await fetch(`${base_url}chat/${chat_id.value}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Authorization: 'Bearer ' + localStorage.getItem('token'),
      },
      body: JSON.stringify(chat_history),
    })
  } catch (e: any) {}
}

async function sendMessage() {
  try {
    loading.value = true

    const message_copy = message.value
    message.value = ''
    const chat_to_send = chat.value.slice()
    chat.value.push({
      role: 'user',
      content: message_copy,
    })
    if (chat.value.length === 1) {
      chat_id.value = await createChat()
    }
    const response = await fetch(
      `${base_url}chat/generate?` +
        new URLSearchParams({
          query: message_copy,
        }),
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: 'Bearer ' + localStorage.getItem('token'),
        },
        body: JSON.stringify(chat_to_send),
      }
    )

    // stream
    const reader = response.body?.getReader()

    const stream = new ReadableStream({
      start(controller) {
        chat.value.push({
          content: '',
          role: 'assistant',
        })
        // The following function handles each data chunk
        function push() {
          // "done" is a Boolean and value a "Uint8Array"
          reader?.read().then(({ done, value }) => {
            // Is there no more data to read?
            if (done) {
              // Tell the browser that we have finished sending data
              controller.close()

              // Update the chat after the assistant has finished sending data
              loading.value = false

              updateChat(chat.value)
              forceHistoryRerender()
              return
            }
            // Get the data and send it to the browser via the controller
            const text = new TextDecoder().decode(value)
            chat.value[chat.value.length - 1].content += text
            controller.enqueue(value)

            // Continue pushing data
            push()
          })
        }
        console.log(chat.value)
        push()
      },
    })
  } catch (e: any) {
    console.log(e)
  } finally {
  }
}

async function getChat(id: number) {
  try {
    console.log(id)
    const response = await axios.get(`chat/${id}`, {
      headers: {
        Authorization: 'Bearer ' + localStorage.getItem('token'),
      },
    })
    console.log(response.data)
    chat.value = response.data
    chat_id.value = id
  } catch (e: any) {}
}

onMounted(() => {
  const token = localStorage.getItem('token')
  if (!token || isTokenExpired(token)) {
    router.push('/login')
  }
})
</script>
\end{Verbatim}

\section{Unit Testing}

Unit testing is a level of software testing where individual units or components of a software are tested. The purpose is to validate that each unit of the software code performs as expected. In this project, we have two main modules to test: the User module and the Chat module.

\subsection{User Module}

The User module is responsible for managing user data. This includes creating new users and handling user login. The tests for this module are defined in \textit{test\_users.py}. These tests ensure that the User module functions as expected, providing a solid foundation for the overall functionality of the chatbot application.\\\\
\textbf{test\_users.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
import pytest
from jose import jwt
from app import schemas
from app.config import settings


SECRET_KEY = settings.secret_key
ALGORITHM = settings.algorithm


def test_create_user(client):
    response = client.post(
        "/users/",
        json={
            "email": "test@example.com",
            "password": "password",
        },
    )
    new_user = schemas.UserOut(**response.json())
    assert response.status_code == 201
    assert new_user.email == "test@example.com"


def test_login_user(client, test_user):
    res = client.post(
        "/login",
        data={
            "username": test_user["email"],
            "password": test_user["password"],
        },
    )
    login_res = schemas.Token(**res.json())
    payload = jwt.decode(login_res.access_token, SECRET_KEY, algorithms=[ALGORITHM])
    id = payload.get("user_id")
    assert id == test_user["id"]
    assert login_res.token_type == "bearer"
    assert res.status_code == 200


@pytest.mark.parametrize(
    "email, password, status_code",
    [
        (
            "wrongemail.@example.com",
            "password",
            403,
        ),
        (
            "test@example.com",
            "wrongpassword",
            403,
        ),
        (
            "wrongemail@example.com",
            "wrongpassword",
            403,
        ),
        (
            None,
            "password",
            422,
        ),
        (
            "test@example.com",
            None,
            422,
        ),
    ],
)
def test_invalid_login(client, test_user, email, password, status_code):
    res = client.post(
        "/login",
        data={
            "username": email,
            "password": password,
        },
    )
    assert res.status_code == status_code
\end{Verbatim}

\subsection{Chat Module}

The Chat module is responsible for managing chat data. This includes retrieving all chats, retrieving a single chat, creating a new chat, and updating an existing chat. The tests for this module are defined in \textit{test\_chats.py}.\\\\
\textbf{test\_chats.py}

\begin{Verbatim}[breaklines=true, breakanywhere=true]
from app import schemas

def test_get_all_chats(authorized_client, test_chats):
    res = authorized_client.get("/chat/")
    posts_list = [schemas.ChatOut(**chat) for chat in res.json()]
    assert len(res.json()) == len(test_chats)
    assert res.status_code == 200


def test_unauthorized_user_get_all_chats(client, test_chats):
    res = client.get("/chat/")
    assert res.status_code == 401


def test_unauthorized_user_get_one_chat(client, test_chats):
    res = client.get(f"/chat/{test_chats[0].id}")
    assert res.status_code == 401


def test_get_one_chat_not_found(authorized_client, test_chats):
    res = authorized_client.get("/chat/999")
    assert res.status_code == 404


def test_get_one_chat(authorized_client, test_chats):
    res = authorized_client.get(f"/chat/{test_chats[0].id}")
    assert res.status_code == 200
    assert str(res.json()) == test_chats[0].history


def test_create_chat(authorized_client, test_user):
    res = authorized_client.post("/chat/")
    created_chat = schemas.ChatCreateOut(**res.json())
    assert res.status_code == 201


def test_unauthorized_user_create_chat(client):
    res = client.post("/chat/")
    assert res.status_code == 401


def test_unauthorized_user_update_chat(client, test_chats):
    res = client.put(f"/chat/{test_chats[0].id}", json={"history": []})
    assert res.status_code == 401


def test_update_chat(authorized_client, test_chats):
    new_history = [{"role": "user", "content": "Updated message"}]
    res = authorized_client.put(f"/chat/{test_chats[0].id}", json=new_history)
    assert res.status_code == 200
    assert res.json()["message"] == "Chat updated successfully"


def test_update_chat_not_found(authorized_client):
    new_history = [{"role": "user", "content": "Updated message"}]
    res = authorized_client.put("/chat/999", json=new_history)

    assert res.status_code == 404
\end{Verbatim}


